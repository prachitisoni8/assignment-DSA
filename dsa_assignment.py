# -*- coding: utf-8 -*-
"""DSA assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uz6H0Lbj4lkGKHje9VH6zVvz-OjPCoWz
"""

#Q1---Write a program to find all pairs of an integer array whose sum is equal to a given number?

def find_pairs_with_sum(arr, target_sum):
    pairs = []
    seen = set()

    for num in arr:
        complement = target_sum - num
        if complement in seen:
            pairs.append((num, complement))
        seen.add(num)

    return pairs

arr = [1, 2, 3, 4, 5, 6]
target_sum = 7
result = find_pairs_with_sum(arr, target_sum)
print(result)

#Q2 Write a program to reverse an array in place? In place means you cannot create a new array. You have to update the original array.

def reverse_array_in_place(arr):
    left = 0
    right = len(arr) - 1

    while left < right:
        arr[left], arr[right] = arr[right], arr[left]

        # Move the indices towards the center
        left += 1
        right -= 1

arr = [1, 2, 3, 4, 5]
reverse_array_in_place(arr)
print(arr)

# Q3 --- Write a program to check if two strings are a rotation of each other?


def are_rotations(str1, str2):
# Check if the lengths of the two strings are equal
    if len(str1) != len(str2):
        return False

# Concatenate one string with itself to create a new string
    concatenated_str = str1 + str1

# Check if the other string is a substring of the concatenated string
    if str2 in concatenated_str:
        return True
    else:
        return False

string1 = "abcde"
string2 = "deabc"
result = are_rotations(string1, string2)
if result:
    print(f"{string1} and {string2} are rotations of each other.")
else:
    print(f"{string1} and {string2} are not rotations of each other.")

# Q4--Write a program to print the first non-repeated character from a string?

def first_non_repeated_char(string):
# Create a dictionary to store character frequencies
    char_count = {}

# Iterate through the string and count character frequencies
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

# Iterate through the string again to find the first non-repeated character
    for char in string:
        if char_count[char] == 1:
            return char

# If no non-repeated character is found, return None
    return None

input_string = "abcdefgabc"
result = first_non_repeated_char(input_string)
if result:
    print(f"The first non-repeated character in '{input_string}' is '{result}'.")
else:
    print("There are no non-repeated characters in the string.")

#Q5 Read about the Tower of Hanoi algorithm. Write a program to implement it.

def tower_of_hanoi(n, source, auxiliary, destination):
    if n == 1:
        # Base case: If there's only one disk, move it from source to destination
        print(f"Move disk 1 from {source} to {destination}")
        return
    # Move n-1 disks from source to auxiliary peg using the destination peg as an auxiliary peg
    tower_of_hanoi(n-1, source, destination, auxiliary)
    # Move the nth disk from source to destination peg
    print(f"Move disk {n} from {source} to {destination}")
    # Move the n-1 disks from auxiliary peg to destination peg using the source peg as an auxiliary peg
    tower_of_hanoi(n-1, auxiliary, source, destination)

num_disks = 3
tower_of_hanoi(num_disks, 'A', 'B', 'C')

#Q6--. Read about infix, prefix, and postfix expressions. Write a program to convert postfix to prefix expression.

def postfix_to_prefix(postfix_expression):
    stack = []

    operators = set(['+', '-', '*', '/', '^'])

    for token in postfix_expression:
        if token not in operators:
            # Operand: push onto the stack
            stack.append(token)
        else:

# Operator: pop top two operands, combine, and push back onto the stack
            operand2 = stack.pop()
            operand1 = stack.pop()
            new_expression = token + operand1 + operand2
            stack.append(new_expression)

# The final item on the stack is the prefix expression
    if len(stack) != 1:
        raise ValueError("Invalid postfix expression")

    return stack[0]

postfix_expression = "23+5*"
prefix_expression = postfix_to_prefix(postfix_expression)
print("Prefix expression:", prefix_expression)

#Q7 --- Write a program to convert prefix expression to infix expression.

def is_operator(char):
    return char in ['+', '-', '*', '/', '^']

def prefix_to_infix(prefix_expression):
    stack = []

    operators = set(['+', '-', '*', '/', '^'])

    # Read the prefix expression from right to left
    for token in reversed(prefix_expression):
        if not is_operator(token):
            # Operand: push onto the stack
            stack.append(token)
        else:
            # Operator: pop top two operands, combine, and push back onto the stack
            operand1 = stack.pop()
            operand2 = stack.pop()
            new_expression = f"({operand1}{token}{operand2})"
            stack.append(new_expression)

    # The final item on the stack is the infix expression
    if len(stack) != 1:
        raise ValueError("Invalid prefix expression")

    return stack[0]

prefix_expression = "+*23*45"
infix_expression = prefix_to_infix(prefix_expression)
print("Infix expression:", infix_expression)

#Q8---- Write a program to check if all the brackets are closed in a given code snippet.

def are_brackets_balanced(code):
    stack = []
    opening_brackets = "([{"
    closing_brackets = ")]}"

    for char in code:
        if char in opening_brackets:
            # If an opening bracket is encountered, push it onto the stack
            stack.append(char)
        elif char in closing_brackets:
            # If a closing bracket is encountered, check if it matches the top of the stack
            if not stack:
                return False  # No matching opening bracket
            top = stack.pop()
            if not is_matching(top, char):
                return False  # Mismatched brackets

    # At the end, the stack should be empty if all brackets are balanced
    return not stack

def is_matching(opening, closing):
    # Helper function to check if opening and closing brackets match
    return (opening == '(' and closing == ')') or \
           (opening == '[' and closing == ']') or \
           (opening == '{' and closing == '}')


code_snippet = "{[()]}"
result = are_brackets_balanced(code_snippet)
if result:
    print("Brackets are balanced.")
else:
    print("Brackets are not balanced.")

#Q9---. Write a program to reverse a stack.

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def peek(self):
        if not self.is_empty():
            return self.items[-1]

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

def reverse_stack(stack):
    if not stack.is_empty():
        # Pop the top element from the stack
        temp = stack.pop()
        # Reverse the remaining elements in the stack
        reverse_stack(stack)
        # Insert the popped element at the bottom of the reversed stack
        insert_at_bottom(stack, temp)

def insert_at_bottom(stack, item):
    if stack.is_empty():
        stack.push(item)
    else:
        temp = stack.pop()
        insert_at_bottom(stack, item)
        stack.push(temp)

stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
print("Original Stack:", stack.items)
reverse_stack(stack)
print("Reversed Stack:", stack.items)

#10--- Write a program to find the smallest number using a stack.


class StackWithMin:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, item):
        self.stack.append(item)
        if not self.min_stack or item <= self.min_stack[-1]:
            self.min_stack.append(item)

    def pop(self):
        if not self.is_empty():
            if self.stack[-1] == self.min_stack[-1]:
                self.min_stack.pop()
            return self.stack.pop()

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]

    def is_empty(self):
        return len(self.stack) == 0

    def get_min(self):
        if not self.is_empty():
            return self.min_stack[-1]

stack = StackWithMin()
stack.push(3)
stack.push(5)
stack.push(2)
stack.push(1)

print("Smallest number in the stack:", stack.get_min())